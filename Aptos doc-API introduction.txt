TypeScript SDK
Github Repo Stars

NPM Version

Node Version

NPM bundle size

Static Badge

The TypeScript SDK allows you to connect, explore, and interact on the Aptos blockchain. You can use it to request data, send transactions, set up test environments, and more!

Terminal window
npm i @aptos-labs/ts-sdk

Examples
Quickstart
See the quickstart to get a working demo in < 5 minutes
20+ Examples
Explore all of the TypeScript examples provided in the SDK repository
Comprehensive Tests
See end to end tests which demonstrate how to use each feature of the SDK
Transfer APT in 10 lines or less
simple_transfer.ts
  // Transfer between users
  const txn = await aptos.transaction.build.simple({
    sender: alice.accountAddress,
    data: {
      function: "0x1::coin::transfer",
      typeArguments: [APTOS_COIN],
      functionArguments: [bob.accountAddress, TRANSFER_AMOUNT],
    },
  });

  console.log("\n=== Transfer transaction ===\n");
  const committedTxn = await aptos.signAndSubmitTransaction({ signer: alice, transaction: txn });

  await aptos.waitForTransaction({ transactionHash: committedTxn.hash });
  console.log(`Committed transaction: ${committedTxn.hash}`);

Creating and Managing Accounts
There are several ways to generate account credentials using the TypeScript SDK. You can use:

Account.generate()
Account.fromPrivateKey()
Account.fromDerivationPath()
Account.generate() is the most commonly used method to create keys for a new account. It defaults to ED25519 key encodings, but you can also manually specify which signing scheme you would prefer like so:

const account = Account.generate(); // defaults to Legacy Ed25519
const account = Account.generate({ scheme: SigningSchemeInput.Secp256k1Ecdsa }); // Single Sender Secp256k1
const account = Account.generate({
  scheme: SigningSchemeInput.Ed25519,
  legacy: false,
}); // Single Sender Ed25519

Note

Following AIP-55 the SDK supports Legacy and Unified authentications. Legacy includes ED25519 and MultiED25519 and Unified includes SingleSender and MultiSender authenticators.

Once you have generated credentials, you must fund it for the network to know it exists.

In localnet / devnet this can be done with a faucet by running the following command:

const transaction = await aptos.fundAccount({
  accountAddress: account.accountAddress,
  amount: 100,
});

For testnet you can use the mint page here.

Other Ways To Represent Accounts
If you have a private key, or equivalent representation, you can use that to create an Account object to manage those credentials while using the TypeScript SDK.

Here are several examples that show how to do so with specific encoding schemes.

Derive an account from private key
The SDK supports deriving an account from a private key with fromPrivateKey() static method. In addition, this method supports deriving an account from a private key and account address. This method uses a local calculation and therefore is used to derive an Account that has not had its authentication key rotated.

// to derive an account with a legacy Ed25519 key scheme
const privateKey = new Ed25519PrivateKey(privateKeyBytes);
const account = Account.fromPrivateKey({ privateKey });

// to derive an account with a Single Sender Ed25519 key scheme
const privateKey = new Ed25519PrivateKey(privateKeyBytes);
const account = Account.fromPrivateKey({ privateKey, legacy: false });

// to derive an account with a Single Sender Secp256k1 key scheme
const privateKey = new Secp256k1PrivateKey(privateKeyBytes);
const account = Account.fromPrivateKey({ privateKey });

// to derive an account with a private key and account address
const privateKey = new Ed25519PrivateKey(privateKeyBytes);
const address = AccountAddress.from(address);
const account = Account.fromPrivateKey({ privateKey, address });

Derive an account from derivation path
The SDK supports deriving an account from derivation path with fromDerivationPath() static method.

// to derive an account with a legacy Ed25519 key scheme
const { mnemonic, address, path } = wallet;
const account = Account.fromDerivationPath({
  path,
  mnemonic,
  scheme: SigningSchemeInput.Ed25519,
});

// to derive an account with a Single Sender Ed25519 key scheme
const { mnemonic, address, path } = wallet;
const account = Account.fromDerivationPath({
  path,
  mnemonic,
  scheme: SigningSchemeInput.Ed25519,
  legacy: false,
});

// to derive an account with a Single Sender Secp256k1 key scheme
const { mnemonic, address, path } = wallet;
const account = Account.fromDerivationPath({
  path,
  mnemonic,
  scheme: SigningSchemeInput.Secp256k1Ecdsa,
});

Building Transactions
Transactions allow you to change on-chain data or trigger events. Generally, transactions follow 5 steps from building to executing on chain: building, simulating, signing, submitting, and waiting.

Note

For these examples, aptos is an instance of the Aptos client object.

Build

Building a transaction is how you specify:

The sender account.
This account normally pays the gas fees for this transaction. See Transaction Sponsoring to learn how to have another account pay for fees.
The function being called on-chain.
This is the identifier for the smart contract entry function on-chain that will trigger when you execute this transaction.
The functionArguments.
This is any data the function needs to run.
This can be packaged into a SimpleTransaction using aptos.transaction.build.simple(...) like so:

const transaction = await aptos.transaction.build.simple({
  sender: sender.accountAddress,
  data: {
    // All transactions on Aptos are implemented via smart contracts.
    function: "0x1::aptos_account::transfer",
    functionArguments: [destination.accountAddress, 100],
  },
});

Note

There is a more advanced format to pass in functionArguments called Binary Canonical Serialization (BCS) format which is how the Aptos chain parses function arguments. The SDK converts TypeScript primitives to BCS format behind the scenes via an API call.

Building Options
You can customize the way your transaction executes by passing in options: {...} when building. Some of the most commonly used options are:

maxGasAmount - This caps the amount of gas you are willing to pay for to execute this transaction.
gasUnitPrice - You can specify a higher than minimum price per gas to be executed with higher priority by the Aptos network.
expireTimestamp - This gives a concrete time the transaction must execute by or it will be canceled.
The SDK provides sensible defaults for these values if they are not specified explicitly.

Simulate (Optional)

Every transaction on the Aptos chain has a gas fee associated with how much work the network machines have to do when executing the transaction. In order to estimate the cost associated with that, you can simulate transactions before committing them.

Note

This simulation only requires the publicKey of an account since it will not impact the actual state of the ledger.

You can execute the simulation by using aptos.transaction.simulate.simple(...) like so:

const [userTransactionResponse] = await aptos.transaction.simulate.simple({
  signerPublicKey: signer.publicKey,
  transaction,
});
// If the fee looks ok, continue to signing!

Sign

Once the transaction is built and the fees seem reasonable, you can sign the transaction with aptos.transaction.sign. The signature must come from the sender account.

// 3. Sign
const senderAuthenticator = aptos.transaction.sign({
  signer: sender,
  transaction,
});

Submit

Now that the transaction is signed, you can submit it to the network using aptos.transaction.submit.simple like so:

// 4. Submit
const committedTransaction = await aptos.transaction.submit.simple({
  transaction,
  senderAuthenticator,
});

Wait

Finally, you can wait for the result of the transaction by using aptos.waitForTransaction and specifying the hash of the transaction you just submitted like so:

// 5. Wait
const executedTransaction = await aptos.waitForTransaction({ transactionHash: committedTransaction.hash });

Full TypeScript Example
/**
 * This example shows how to use the Aptos SDK to send a transaction.
 * Don't forget to install @aptos-labs/ts-sdk before running this example!
 */

import {
    Account,
    Aptos,
    AptosConfig,
    Network,
} from "@aptos-labs/ts-sdk";

async function example() {
    console.log("This example will create two accounts (Alice and Bob) and send a transaction transfering APT to Bob's account.");

    // 0. Setup the client and test accounts
    const config = new AptosConfig({ network: Network.DEVNET });
    const aptos = new Aptos(config);

    let alice = Account.generate();
    let bob = Account.generate();

    console.log("=== Addresses ===\n");
    console.log(`Alice's address is: ${alice.accountAddress}`);
    console.log(`Bob's address is: ${bob.accountAddress}`);

    console.log("\n=== Funding accounts ===\n");
    await aptos.fundAccount({
        accountAddress: alice.accountAddress,
        amount: 100_000_000,
    });
    await aptos.fundAccount({
        accountAddress: bob.accountAddress,
        amount: 100,
    });
    console.log("Funded Alice and Bob's accounts!")

    // 1. Build
    console.log("\n=== 1. Building the transaction ===\n");
    const transaction = await aptos.transaction.build.simple({
        sender: alice.accountAddress,
        data: {
        // All transactions on Aptos are implemented via smart contracts.
        function: "0x1::aptos_account::transfer",
        functionArguments: [bob.accountAddress, 100],
        },
    });
    console.log("Built the transaction!")

    // 2. Simulate (Optional)
    console.log("\n === 2. Simulating Response (Optional) === \n")
    const [userTransactionResponse] = await aptos.transaction.simulate.simple({
        signerPublicKey: alice.publicKey,
        transaction,
    });
    console.log(userTransactionResponse)

    // 3. Sign
    console.log("\n=== 3. Signing transaction ===\n");
    const senderAuthenticator = aptos.transaction.sign({
        signer: alice,
        transaction,
    });
    console.log("Signed the transaction!")

    // 4. Submit
    console.log("\n=== 4. Submitting transaction ===\n");
    const submittedTransaction = await aptos.transaction.submit.simple({
        transaction,
        senderAuthenticator,
    });

    console.log(`Submitted transaction hash: ${submittedTransaction.hash}`);

    // 5. Wait for results
    console.log("\n=== 5. Waiting for result of transaction ===\n");
    const executedTransaction = await aptos.waitForTransaction({ transactionHash: submittedTransaction.hash });
    console.log(executedTransaction)
};

example();

Summary
Building and sending transactions on-chain involves the following 5 steps:

Build the transaction.
Simulate the cost. (Optional)
Sign the transaction (if the simulated cost seems ok).
Submit the transaction to the network.
Wait for the chain to validate and update.
Explore Advanced Transaction Features
Transactions have a couple of additional features which let them adapt to your needs which you can learn about here:

Multi-Agent Transactions - Allowing multiple accounts to interact with a single transaction.
Orderless Transactions - Allowing for transactions to be executed out of order for easier management.
Sponsoring Transactions - Have another account pay gas fees for this transaction.
Batch Submit Transactions - How to send multiple transactions quickly from a single account.
Binary Canonical Serialization (BCS) - The format used to serialize data for Aptos transactions.
Composing multiple Move calls with ScriptComposer - (Experimental) Building more complex transaction payload that calls into multiple Move functions dynamically.

Confidential Asset (CA)
You can use confidentialCoin property of Aptos client to interact with CA

Initialization
Operations in CA require generating zk-proofs (ZKPs), and depending on your environment, you need to define a Range Proof calculation.

For the web, you could use confidential-asset-wasm-bindings/confidential-asset-wasm-bindings:

Let’s prepare range-proof generation and configure SDK to use it:

import initWasm, {
  batch_range_proof as batchRangeProof,
  batch_verify_proof as batchVerifyProof,
  range_proof as rangeProof,
  verify_proof as verifyProof,
} from '@aptos-labs/confidential-asset-wasm-bindings/range-proofs'
import {
  BatchRangeProofInputs,
  BatchVerifyRangeProofInputs,
  RangeProofInputs,
  VerifyRangeProofInputs,
} from '@lukachi/aptos-labs-ts-sdk'

const RANGE_PROOF_WASM_URL =
  'https://unpkg.com/@aptos-labs/confidential-asset-wasm-bindings@0.3.16/range-proofs/aptos_rp_wasm_bg.wasm'

export async function genBatchRangeZKP(
  opts: BatchRangeProofInputs,
): Promise<{ proof: Uint8Array; commitments: Uint8Array[] }> {
  await initWasm({ module_or_path: RANGE_PROOF_WASM_URL })

  const proof = batchRangeProof(
    new BigUint64Array(opts.v),
    opts.rs,
    opts.val_base,
    opts.rand_base,
    opts.num_bits,
  )

  return {
    proof: proof.proof(),
    commitments: proof.comms(),
  }
}

export async function verifyBatchRangeZKP(
  opts: BatchVerifyRangeProofInputs,
): Promise<boolean> {
  await initWasm({ module_or_path: RANGE_PROOF_WASM_URL })

  return batchVerifyProof(
    opts.proof,
    opts.comm,
    opts.val_base,
    opts.rand_base,
    opts.num_bits,
  )
}

And then, just place this at the very top of your app:

import { RangeProofExecutor } from '@aptos-labs/ts-sdk'

RangeProofExecutor.setGenBatchRangeZKP(genBatchRangeZKP);
RangeProofExecutor.setVerifyBatchRangeZKP(verifyBatchRangeZKP);
RangeProofExecutor.setGenerateRangeZKP(generateRangeZKP);
RangeProofExecutor.setVerifyRangeZKP(verifyRangeZKP);

For the native apps:

Generate android and ios bindings here and integrate in your app as you please.

And the last, but not the least important part:

To get a “numeric” value of the confidential balance, you also need to solve a Discrete Logarithm Problem (DLP). CA implements the Pollard’s Kangaroo method for solving DLPs on the Ristretto curve. Source

So we also need to initialize a decryption function for that:

// Copyright © Aptos Foundation
// SPDX-License-Identifier: Apache-2.0

import initWasm, {
  create_kangaroo,
  WASMKangaroo,
} from '@aptos-labs/confidential-asset-wasm-bindings/pollard-kangaroo'
import {
  ConfidentialAmount,
  TwistedEd25519PrivateKey,
  TwistedElGamal,
  TwistedElGamalCiphertext,
} from '@lukachi/aptos-labs-ts-sdk'
import { bytesToNumberLE } from '@noble/curves/abstract/utils'

const POLLARD_KANGAROO_WASM_URL =
  'https://unpkg.com/@aptos-labs/confidential-asset-wasm-bindings@0.3.15/pollard-kangaroo/aptos_pollard_kangaroo_wasm_bg.wasm'

export async function createKangaroo(secret_size: number) {
  await initWasm({ module_or_path: POLLARD_KANGAROO_WASM_URL })

  return create_kangaroo(secret_size)
}

export const preloadTables = async () => {
  const kangaroo16 = await createKangaroo(16)
  const kangaroo32 = await createKangaroo(32)
  const kangaroo48 = await createKangaroo(48)

  TwistedElGamal.setDecryptionFn(async pk => {
    if (bytesToNumberLE(pk) === 0n) return 0n

    let result = kangaroo16.solve_dlp(pk, 500n)

    if (!result) {
      result = kangaroo32.solve_dlp(pk, 1500n)
    }

    if (!result) {
      result = kangaroo48.solve_dlp(pk)
    }

    if (!result) throw new TypeError('Decryption failed')

    return result
  })
}

Now, place this at the top of your app:

const init = async () => {
  await preloadTables();
}

For the native apps, you could generate android and ios bindings here to use instead of WASM.

Now we are ready to go. Let’s define Aptos client:

const APTOS_NETWORK: Network = NetworkToNetworkName[Network.TESTNET];
const config = new AptosConfig({ network: APTOS_NETWORK });
export const aptos = new Aptos(config);

Create Decryption Key (DK)
To interact with the confidential asset, create a unique key pair first.

Generate new:

const dk = TwistedEd25519PrivateKey.generate();

Or import existed one:

const dk = new TwistedEd25519PrivateKey("0x...");

Also, you could derive it using your signature (for testing purposes, don’t use at production):

const user = Account.generate()

const signature = user.sign(TwistedEd25519PrivateKey.decryptionKeyDerivationMessage);

const dk = TwistedEd25519PrivateKey.fromSignature(signature);

Or use pepper from Keyless Account

Register
Next, you need to register a previously generated encryption key (EK) in contracts:

export const registerConfidentialBalance = async (
  account: Account,
  publicKeyHex: string,
  tokenAddress = "0x...",
) => {
  const txBody = await aptos.confidentialAsset.deposit({
    sender: account.accountAddress,
    to: AccountAddress.from(to),
    tokenAddress: tokenAddress,
    amount: amount,
  })

  const txResponse = await aptos.signAndSubmitTransaction({ signer: user, transaction: userRegisterCBTxBody });

  const txReceipt = await aptos.waitForTransaction({ transactionHash: txResponse.hash });

  return txReceipt;
}

Check if a user has already registered a specific token:

export const getIsAccountRegisteredWithToken = async (
  account: Account,
  tokenAddress = "0x...",
) => {
  const isRegistered = await aptos.confidentialAsset.hasUserRegistered({
    accountAddress: account.accountAddress,
    tokenAddress: tokenAddress,
  })

  return isRegistered
}

Deposit
Let’s say you already have tokens.

This will deposit them to your confidential balance

export const depositConfidentialBalance = async (
  account: Account,
  amount: bigint,
  to: string,
  tokenAddress = "0x...",
) => {
  const txBody = await aptos.confidentialAsset.deposit({
    sender: account.accountAddress,
    to: AccountAddress.from(to),
    tokenAddress: tokenAddress,
    amount: amount,
  })
  // Sign and send transaction
}

Get user’s balance
Let’s check the user’s balance after the deposit.

const userConfidentialBalance = await aptos.confidentialAsset.getBalance({ accountAddress: user.accountAddress, tokenAddress: TOKEN_ADDRESS });

This method returns you the user’s pending and actual confidential balances, and to decrypt them, you can use ConfidentialAmount class

export const getConfidentialBalances = async (
  account: Account,
  decryptionKeyHex: string,
  tokenAddress = "0x...",
) => {
  const decryptionKey = new TwistedEd25519PrivateKey(decryptionKeyHex)

  const { pending, actual } = await aptos.confidentialAsset.getBalance({
    accountAddress: account.accountAddress,
    tokenAddress,
  })

  try {
    const [confidentialAmountPending, confidentialAmountActual] =
      await Promise.all([
        ConfidentialAmount.fromEncrypted(pending, decryptionKey),
        ConfidentialAmount.fromEncrypted(actual, decryptionKey),
      ])

    return {
      pending: confidentialAmountPending,
      actual: confidentialAmountActual,
    }
  } catch (error) {
    return {
      pending: ConfidentialAmount.fromAmount(0n),
      actual: ConfidentialAmount.fromAmount(0n),
    }
  }
}

Rollover
After you deposited to user’s confidential balance, you can see, that he has, for instance 5n at his pending balance, and 0n at his actual balance.

User can’t operate with pending balance, so you could rollover it to actual one.

And to do so - use aptos.confidentialAsset.rolloverPendingBalance.

Caution

Important note, that user’s actual balance need to be normalized before rollover operation.

To cover normalization & rollover simultaneously, you could use aptos.confidentialAsset.safeRolloverPendingCB.

export const safelyRolloverConfidentialBalance = async (
  account: Account,
  decryptionKeyHex: string,
  tokenAddress = "0x...",
) => {
  const rolloverTxPayloads = await aptos.confidentialAsset.safeRolloverPendingCB({
    sender: account.accountAddress,
    tokenAddress,
    decryptionKey: new TwistedEd25519PrivateKey(decryptionKeyHex),
  })

  // Sign and send batch txs
}

Normalization
Usually you don’t need to explicitly call normalization

In case you want to:

Caution

Firstly, check a confidential balance is normalized, because trying to normalize an already normalized balance will return you an exception

export const getIsBalanceNormalized = async (
  account: Account,
  tokenAddress = "0x...",
) => {
  const isNormalized = await aptos.confidentialAsset.isUserBalanceNormalized({
    accountAddress: account.accountAddress,
    tokenAddress: tokenAddress,
  })

  return isNormalized
}

Get your balance and finally call the aptos.confidentialAsset.normalizeUserBalance method:

export const normalizeConfidentialBalance = async (
  account: Account,
  decryptionKeyHex: string,
  encryptedPendingBalance: TwistedElGamalCiphertext[],
  amount: bigint,
  tokenAddress = "0x...",
) => {
  const normalizeTx = await aptos.confidentialAsset.normalizeUserBalance({
    tokenAddress,
    decryptionKey: new TwistedEd25519PrivateKey(decryptionKeyHex),
    unnormalizedEncryptedBalance: encryptedPendingBalance,
    balanceAmount: amount,

    sender: account.accountAddress,
  })

  // Sign and send transaction
}

Withdraw
To withdraw your assets out from confidential balance:

export const withdrawConfidentialBalance = async (
  account: Account,
  receiver: string,
  decryptionKeyHex: string,
  withdrawAmount: bigint,
  encryptedActualBalance: TwistedElGamalCiphertext[],
  tokenAddress = '0x...',
) => {
  const withdrawTx = await aptos.confidentialAsset.withdraw({
    sender: account.accountAddress,
    to: receiver,
    tokenAddress,
    decryptionKey: decryptionKey,
    encryptedActualBalance,
    amountToWithdraw: withdrawAmount,
  })

  // Sign and send transaction
}

Transfer
For transfer you need to know the recipient’s encryption key and aptos account address

Let’s say you have a recipient’s account address, let’s get their encryption key.

export const getEkByAddr = async (addrHex: string, tokenAddress: string) => {
  return aptos.confidentialAsset.getEncryptionByAddr({
    accountAddress: AccountAddress.from(addrHex),
    tokenAddress,
  })
}

Now, wrap it all together and transfer:

export const transferConfidentialCoin = async (
  account: Account,
  decryptionKeyHex: string,
  encryptedActualBalance: TwistedElGamalCiphertext[],
  amountToTransfer: bigint,
  recipientAddressHex: string,
  auditorsEncryptionKeyHexList: string[],
  tokenAddress = "0x...",
) => {
  const decryptionKey = new TwistedEd25519PrivateKey(decryptionKeyHex)

  const recipientEncryptionKeyHex = await getEkByAddr(
    recipientAddressHex,
    tokenAddress,
  )

  const transferTx = await aptos.confidentialAsset.transferCoin({
    senderDecryptionKey: decryptionKey,
    recipientEncryptionKey: new TwistedEd25519PublicKey(
      recipientEncryptionKeyHex,
    ),
    encryptedActualBalance: encryptedActualBalance,
    amountToTransfer,
    sender: account.accountAddress,
    tokenAddress,
    recipientAddress: recipientAddressHex,
    auditorEncryptionKeys: auditorsEncryptionKeyHexList.map(
      hex => new TwistedEd25519PublicKey(hex),
    ),
  })

  // Sign and send transaction
}

Key Rotation
To do key rotation, you need to create a new decryption key and use aptos.confidentialAsset.rotateCBKey

Caution

But keep in mind, that key-rotation checks that pending balance equals 0. In that case, we could do a rollover with freeze option, to move assets from the pending balance to the actual one and lock our balance.

aptos.confidentialAsset.safeRolloverPendingCB({
  ...,
  withFreezeBalance: false,
})

Now let’s create a new decryption key and rotate our encryption key:

const balances = await getBalances(user.accountAddress.toString(), myDecryptionKey, TOKEN_ADDRESS);

const NEW_DECRYPTION_KEY = TwistedEd25519PrivateKey.generate();
const keyRotationAndUnfreezeTxResponse = await ConfidentialCoin.safeRotateCBKey(aptos, user, {
  sender: user.accountAddress,

  currDecryptionKey: currentDecryptionKey,
  newDecryptionKey: NEW_DECRYPTION_KEY,

  currEncryptedBalance: balances.actual.amountEncrypted,

  withUnfreezeBalance: true, // if you want to unfreeze balance after
  tokenAddress: TOKEN_ADDRESS,
});

// save: new decryption key
console.log(NEW_DECRYPTION_KEY.toString());

// check new balances
const newBalance = await getBalances(user.accountAddress.toString(), NEW_DECRYPTION_KEY, TOKEN_ADDRESS);

console.log(newBalance.pending.amount);
console.log(newBalance.actual.amount);

Fetch Data via SDK
You can use the Aptos client to get on-chain data using a variety of helper functions. Specifically, many of the functions listed in the reference docs here that start with get... will retrieve data from on-chain.

Here’s an example showing how to fetch common data you may need in your application:

const aptosConfig = new AptosConfig({ network: Network.DEVNET });
const aptos = new Aptos(aptosConfig);

const fund = await aptos.getAccountInfo({ accountAddress: "0x123" });
const modules = await aptos.getAccountModules({ accountAddress: "0x123" });
const tokens = await aptos.getAccountOwnedTokens({ accountAddress: "0x123" });

Note

Many queries have a parameter named options to customize the results, use it to get specifically what you are looking for.

The Aptos client can out of the box query both network data from fullnodes and the Indexer API which contains aggregated and enriched data. If you want to use a custom query for Indexer API data, you can use aptos.queryIndexer like so:

  const ledgerInfo = await aptos.queryIndexer({
    query: {
      query: `
        query MyQuery {
          ledger_infos {
            chain_id
          }
        }
      `
    }
  })

Using Generic Queries
Some queries are intentionally broad, but this can make inferring the proper return type difficult. To accommodate that, these broad requests like getAccountResources allow you to specify what the expected response type should be.

type Coin = { coin: { value: string } };

const resource = await aptos.getAccountResource<Coin>({
  accountAddress: testAccount.accountAddress,
  resourceType: "0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>",
});

// Now you have access to the response type property
const value = resource.coin.value;

Using Move View Functions
You can call view functions which return custom data from on-chain by using aptos.view.

For example, you can look up the network you are using with the chain_id view function:

const payload: InputViewFunctionData = {
  function: "0x1::chain_id::get",
};

const chainId = (await aptos.view({ payload }))[0];

Ensuring Fresh Indexer Data
Behind the scenes, some requests use the Indexer API to access data which has been processed or aggregated. That extra parsing can take a bit of time, so the data may lag slightly behind the latest ledger.

If you want to ensure that the data is fresh, you can specify the minimumLedgerVersion in any request which uses the Indexer API.

// Get the latest ledger version number
const ledgerVersion = await aptos.getLedgerInfo().ledger_version;

const tokens = await aptos.getAccountOwnedTokens({
  accountAddress: alice.accountAddress,
  minimumLedgerVersion: BigInt(response.version),
});

You can also ensure that your request has the data from a transaction you submitted by getting the ledger version from the transaction validation itself.

// Wait for a transaction you just submitted
const response = await aptos.waitForTransaction({
  transactionHash: pendingTransaction.hash,
});

// Then look up how that transaction affected alice's account
const tokens = await aptos.getAccountOwnedTokens({
  accountAddress: alice.accountAddress,
  minimumLedgerVersion: BigInt(response.version),
});

TypeScript SDK Quickstart
Note

The complete example code can be found at Full Quickstart Code at the bottom of the page.

Initialize A Project

This will initialize a typescript package with quickstart.ts

npm
pnpm
yarn
Terminal window
npm init && npm add -D typescript @types/node ts-node && npx tsc --init && mkdir src && echo 'async function example() { console.log("Running example!")}; example()' > src/quickstart.ts

Test Initialization

To test if you have initialized the package correctly run:

npm
pnpm
yarn
Terminal window
npx ts-node src/quickstart.ts

Install the TypeScript SDK using the package manager of your choice:

Terminal window
npm i @aptos-labs/ts-sdk

Set up the Aptos client

You can use the Aptos object to handle everything that requires a connection to the Aptos network. A connection is established as soon as you create the object.

import { Account, Aptos, AptosConfig, Network } from "@aptos-labs/ts-sdk";

// Specify which network to connect to via AptosConfig
async function example() {
  console.log(
    "This example will create two accounts (Alice and Bob), fund them, and transfer between them.",
  );

  // Setup the client
  const config = new AptosConfig({ network: Network.DEVNET });
  const aptos = new Aptos(config);
}

example()

Note

(Advanced) If you need to connect to a specific node, you can set that in the AptosConfig by specifying the fullnode url. Ex. fullnode: http://localhost:8080/v1.

Fetch data from on-chain

You can use the Aptos client to fetch all sorts of data from on-chain such as information about the network itself or account-specific information.

...
const ledgerInfo = await aptos.getLedgerInfo();
const modules = await aptos.getAccountModules({ accountAddress: "0x123" });
const tokens = await aptos.getAccountOwnedTokens({ accountAddress: "0x123" });
...

Send Transactions

You can send transactions to change the state of the ledger. Transactions let you send tokens like APT, trigger Move modules, trade NFTs, and more. You can find an in-depth tutorial on transactions here.

To begin with though, here’s how you can send a basic transaction to transfer APT.

1. Create an Account
To create a new account, you first generate new credentials then fund the account. On localnet / devnet you can fund an account programmatically by asking a “faucet” which has a lot of test APT to send some to your new account.

...
// Generate a new account key pair
const alice: Account = Account.generate();

// Fund the account on chain. Funding an account creates it on-chain.
await aptos.fundAccount({
  accountAddress: alice.accountAddress,
  amount: 100000000,
});

// Also create a second account to transfer tokens to
const bob: Account = Account.generate();

// Fund the account on chain
await aptos.fundAccount({
  accountAddress: bob.accountAddress,
  amount: 100000000,
});
...

2. Build the Transaction
You can build transactions with aptos.transaction.build.simple({...}) by specifying:

sender - The account that’s sending the transaction. This account will pay the gas fees.
data - The information needed for Aptos to identify what transaction to execute.
function - Which smart contract on chain to call. This has the format <account_address>::<move_module>::<function>.
functionArguments - These are specific to the function being called. You can look up what parameters a function needs by searching for the account and module on chain with an explorer like this.
For example:

...
const transaction = await aptos.transaction.build.simple({
  sender: alice.accountAddress,
  data: {
    // The Move entry-function
    function: "0x1::aptos_account::transfer",
    functionArguments: [bob.accountAddress, 100],
  },
});
...

Note

For some situations, you can also use simplified functions in the SDK such as transferCoinTransaction.

3. Sign and Submit
Signing proves that you own or manage the account that is executing the transaction. This is important since the sender must pay gas fees for the work the network does to execute the transaction.

Once signed, you can submit to the network for on chain verification and execution.

You can use aptos.signAndSubmitTransaction which combines those two steps into one:

...
// Both signs and submits (although these can be done separately too)
const pendingTransaction = await aptos.signAndSubmitTransaction({
  signer: alice,
  transaction,
});
...

4. Wait for completion
You can run aptos.waitForTransaction to guarantee your code executes after the transaction has been processed and applied.

This also helps you get any errors that may occur after submitting, such as the transaction being rejected.

...
const executedTransaction = await aptos.waitForTransaction({ transactionHash: pendingTransaction.hash });
...

Full Quickstart Code
Run Quickstart
npm
pnpm
yarn
Terminal window
npx ts-node src/quickstart.ts

/**
 * This example shows how to use the Aptos client to create accounts, fund them, and transfer between them.
 */

import { Account, Aptos, AptosConfig, Network } from "@aptos-labs/ts-sdk";

const APTOS_COIN = "0x1::aptos_coin::AptosCoin";
const COIN_STORE = `0x1::coin::CoinStore<${APTOS_COIN}>`;
const ALICE_INITIAL_BALANCE = 100_000_000;
const BOB_INITIAL_BALANCE = 100;
const TRANSFER_AMOUNT = 100;

async function example() {
  console.log(
    "This example will create two accounts (Alice and Bob), fund them, and transfer between them.",
  );

  // Setup the client
  const config = new AptosConfig({ network: Network.DEVNET });
  const aptos = new Aptos(config);

  // Generate two account credentials
  // Each account has a private key, a public key, and an address
  const alice = Account.generate();
  const bob = Account.generate();

  console.log("=== Addresses ===\n");
  console.log(`Alice's address is: ${alice.accountAddress}`);
  console.log(`Bob's address is: ${bob.accountAddress}`);

  // Fund the accounts using a faucet
  console.log("\n=== Funding accounts ===\n");

  await aptos.fundAccount({
    accountAddress: alice.accountAddress,
    amount: ALICE_INITIAL_BALANCE,
  });

  await aptos.fundAccount({
    accountAddress: bob.accountAddress,
    amount: BOB_INITIAL_BALANCE,
  });
  console.log("Alice and Bob's accounts have been funded!");

  // Look up the newly funded account's balances
  console.log("\n=== Balances ===\n");
  const aliceAccountBalance = await aptos.getAccountResource({
    accountAddress: alice.accountAddress,
    resourceType: COIN_STORE,
  });
  const aliceBalance = Number(aliceAccountBalance.coin.value);
  console.log(`Alice's balance is: ${aliceBalance}`);

  const bobAccountBalance = await aptos.getAccountResource({
    accountAddress: bob.accountAddress,
    resourceType: COIN_STORE,
  });
  const bobBalance = Number(bobAccountBalance.coin.value);
  console.log(`Bob's balance is: ${bobBalance}`);

  // Send a transaction from Alice's account to Bob's account
  const txn = await aptos.transaction.build.simple({
    sender: alice.accountAddress,
    data: {
      // All transactions on Aptos are implemented via smart contracts.
      function: "0x1::aptos_account::transfer",
      functionArguments: [bob.accountAddress, 100],
    },
  });

  console.log("\n=== Transfer transaction ===\n");
  // Both signs and submits
  const committedTxn = await aptos.signAndSubmitTransaction({
    signer: alice,
    transaction: txn,
  });
  // Waits for Aptos to verify and execute the transaction
  const executedTransaction = await aptos.waitForTransaction({
    transactionHash: committedTxn.hash,
  });
  console.log("Transaction hash:", executedTransaction.hash);

  console.log("\n=== Balances after transfer ===\n");
  const newAliceAccountBalance = await aptos.getAccountResource({
    accountAddress: alice.accountAddress,
    resourceType: COIN_STORE,
  });
  const newAliceBalance = Number(newAliceAccountBalance.coin.value);
  console.log(`Alice's balance is: ${newAliceBalance}`);

  const newBobAccountBalance = await aptos.getAccountResource({
    accountAddress: bob.accountAddress,
    resourceType: COIN_STORE,
  });
  const newBobBalance = Number(newBobAccountBalance.coin.value);
  console.log(`Bob's balance is: ${newBobBalance}`);

  // Bob should have the transfer amount
  if (newBobBalance !== TRANSFER_AMOUNT + BOB_INITIAL_BALANCE)
    throw new Error("Bob's balance after transfer is incorrect");

  // Alice should have the remainder minus gas
  if (newAliceBalance >= ALICE_INITIAL_BALANCE - TRANSFER_AMOUNT)
    throw new Error("Alice's balance after transfer is incorrect");
}

example();

Summary
All told, you just learned how to transfer APT via a transaction by:

Connecting to the network using the Aptos client.
Creating an account.
Looking up data from on-chain using client helper functions like aptos.getAccountModules.
Signing and submitting a transaction to the network.
Waiting for Aptos to execute the transaction.
To see all this in action, you can copy and run the full working code snippet for this quickstart above.

TypeScript SDK Example Code
For sample code which explains the core concepts of how to use the SDK, see:

Fetching Data
Building, Simulating, and Submitting Transactions
Below are additional resources which may be more suited for your individual use case.

Code Snippets
The examples folder in the SDK repo has dozens of code snippets you can customize to your needs.

How to run examples
To run one of the example scripts:

Clone the

Terminal window
git clone https://github.com/aptos-labs/aptos-ts-sdk.git

From the top-level of the package, install all dependencies.

Terminal window
pnpm install

Build the package.

Terminal window
pnpm build

Go to the folder of an example you would like to run.

Terminal window
cd examples/typescript

Install local dependencies.

Terminal window
pnpm install

Run the example.

Terminal window
pnpm run simple_transfer

Helpful Reference Code
The SDK’s end-to-end tests - This has the most comprehensive set of code that uses the SDK.
SDK source code - This has in-line comments explaining what each function does.
SDK reference docs - These are another way to view the in-line documentation with built-in search.

Surf: TypeScript Type Safety for Move Contracts
What is Surf
Surf is a TypeScript library built on top of the Aptos TypeScript SDK and the wallet adapter that provides static type safety for your Move contracts by inferring type from contract ABI (Application Binary Interface). It allows you to catch type errors at compile time rather than at runtime. Most existing TypeScript IDEs will automatically provide warnings if you try to access fields that don’t exist, or provide wrong input types.

Usage
Step 1

First, download the ABI of the Move contract and save it to a TypeScript file. In this case, we’re naming the file abi.ts in the src/utils folder.

macOS & Linux
Windows
#! /bin/bash

# replace it with the network your contract lives on
NETWORK=testnet
# replace it with your contract address
CONTRACT_ADDRESS=0x12345
# replace it with your module name, every .move file except move script has module_address::module_name {}
MODULE_NAME=fungible_asset_launchpad

# save the ABI to a TypeScript file
echo "export const ABI = $(curl https://fullnode.$NETWORK.aptoslabs.com/v1/accounts/$CONTRACT_ADDRESS/module/$MODULE_NAME | sed -n 's/.*"abi":\({.*}\).*}$/\1/p') as const" > abi.ts

Step 2

With the ABI, you can use Surf as a layer on top of the Aptos TypeScript SDK client Aptos, when interacting with Move contracts. For non-contract related operations, the Aptos will still need to be used.

import { createSurfClient } from '@thalalabs/surf';
import { Aptos, AptosConfig, NETWORK } from "@aptos-labs/ts-sdk";
import { ABI } from "./abi";

// First, create an Aptos client, make sure the network is the one that contract lives on
export const aptos = new Aptos(new AptosConfig({ network: Network.DEVNET }));
// Second, create a SurfClient with the Aptos client and the ABI
export const surfClient = createSurfClient(aptos).useABI(ABI);

// Use Surf to executes an entry function
const result = await surfClient.entry.transfer({
  functionArguments: ['0x1', 1],
  typeArguments: ['0x1::aptos_coin::AptosCoin'],
  account: Account.fromPrivateKey(...),
});

// Use Surf to query a view function
const [balance] = await surfClient.view.balance({
  functionArguments: ['0x1'],
  typeArguments: ['0x1::aptos_coin::AptosCoin'],
});

Resources
Surf GitHub
A simple Next.js example demonstrating Surf
An example of a fungible asset launchpad using Surf: This example is part of the Solana to Aptos guide on Aptos Learn, you can try it here and read the complete tutorial here.
Credits
Surf is built by Thala Labs, an Aptos ecosystem project, and maintained together by the Aptos community.

Feedback
If you have any feedback or questions, please open an issue on Surf’s GitHub.

Creating and Managing Accounts
There are several ways to generate account credentials using the TypeScript SDK. You can use:

Account.generate()
Account.fromPrivateKey()
Account.fromDerivationPath()
Account.generate() is the most commonly used method to create keys for a new account. It defaults to ED25519 key encodings, but you can also manually specify which signing scheme you would prefer like so:

const account = Account.generate(); // defaults to Legacy Ed25519
const account = Account.generate({ scheme: SigningSchemeInput.Secp256k1Ecdsa }); // Single Sender Secp256k1
const account = Account.generate({
  scheme: SigningSchemeInput.Ed25519,
  legacy: false,
}); // Single Sender Ed25519

Note

Following AIP-55 the SDK supports Legacy and Unified authentications. Legacy includes ED25519 and MultiED25519 and Unified includes SingleSender and MultiSender authenticators.

Once you have generated credentials, you must fund it for the network to know it exists.

In localnet / devnet this can be done with a faucet by running the following command:

const transaction = await aptos.fundAccount({
  accountAddress: account.accountAddress,
  amount: 100,
});

For testnet you can use the mint page here.

Other Ways To Represent Accounts
If you have a private key, or equivalent representation, you can use that to create an Account object to manage those credentials while using the TypeScript SDK.

Here are several examples that show how to do so with specific encoding schemes.

Derive an account from private key
The SDK supports deriving an account from a private key with fromPrivateKey() static method. In addition, this method supports deriving an account from a private key and account address. This method uses a local calculation and therefore is used to derive an Account that has not had its authentication key rotated.

// to derive an account with a legacy Ed25519 key scheme
const privateKey = new Ed25519PrivateKey(privateKeyBytes);
const account = Account.fromPrivateKey({ privateKey });

// to derive an account with a Single Sender Ed25519 key scheme
const privateKey = new Ed25519PrivateKey(privateKeyBytes);
const account = Account.fromPrivateKey({ privateKey, legacy: false });

// to derive an account with a Single Sender Secp256k1 key scheme
const privateKey = new Secp256k1PrivateKey(privateKeyBytes);
const account = Account.fromPrivateKey({ privateKey });

// to derive an account with a private key and account address
const privateKey = new Ed25519PrivateKey(privateKeyBytes);
const address = AccountAddress.from(address);
const account = Account.fromPrivateKey({ privateKey, address });

Derive an account from derivation path
The SDK supports deriving an account from derivation path with fromDerivationPath() static method.

// to derive an account with a legacy Ed25519 key scheme
const { mnemonic, address, path } = wallet;
const account = Account.fromDerivationPath({
  path,
  mnemonic,
  scheme: SigningSchemeInput.Ed25519,
});

// to derive an account with a Single Sender Ed25519 key scheme
const { mnemonic, address, path } = wallet;
const account = Account.fromDerivationPath({
  path,
  mnemonic,
  scheme: SigningSchemeInput.Ed25519,
  legacy: false,
});

// to derive an account with a Single Sender Secp256k1 key scheme
const { mnemonic, address, path } = wallet;
const account = Account.fromDerivationPath({
  path,
  mnemonic,
  scheme: SigningSchemeInput.Secp256k1Ecdsa,
});

Creating and Managing Accounts
There are several ways to generate account credentials using the TypeScript SDK. You can use:

Account.generate()
Account.fromPrivateKey()
Account.fromDerivationPath()
Account.generate() is the most commonly used method to create keys for a new account. It defaults to ED25519 key encodings, but you can also manually specify which signing scheme you would prefer like so:

const account = Account.generate(); // defaults to Legacy Ed25519
const account = Account.generate({ scheme: SigningSchemeInput.Secp256k1Ecdsa }); // Single Sender Secp256k1
const account = Account.generate({
  scheme: SigningSchemeInput.Ed25519,
  legacy: false,
}); // Single Sender Ed25519

Note

Following AIP-55 the SDK supports Legacy and Unified authentications. Legacy includes ED25519 and MultiED25519 and Unified includes SingleSender and MultiSender authenticators.

Once you have generated credentials, you must fund it for the network to know it exists.

In localnet / devnet this can be done with a faucet by running the following command:

const transaction = await aptos.fundAccount({
  accountAddress: account.accountAddress,
  amount: 100,
});

For testnet you can use the mint page here.

Other Ways To Represent Accounts
If you have a private key, or equivalent representation, you can use that to create an Account object to manage those credentials while using the TypeScript SDK.

Here are several examples that show how to do so with specific encoding schemes.

Derive an account from private key
The SDK supports deriving an account from a private key with fromPrivateKey() static method. In addition, this method supports deriving an account from a private key and account address. This method uses a local calculation and therefore is used to derive an Account that has not had its authentication key rotated.

// to derive an account with a legacy Ed25519 key scheme
const privateKey = new Ed25519PrivateKey(privateKeyBytes);
const account = Account.fromPrivateKey({ privateKey });

// to derive an account with a Single Sender Ed25519 key scheme
const privateKey = new Ed25519PrivateKey(privateKeyBytes);
const account = Account.fromPrivateKey({ privateKey, legacy: false });

// to derive an account with a Single Sender Secp256k1 key scheme
const privateKey = new Secp256k1PrivateKey(privateKeyBytes);
const account = Account.fromPrivateKey({ privateKey });

// to derive an account with a private key and account address
const privateKey = new Ed25519PrivateKey(privateKeyBytes);
const address = AccountAddress.from(address);
const account = Account.fromPrivateKey({ privateKey, address });

Derive an account from derivation path
The SDK supports deriving an account from derivation path with fromDerivationPath() static method.

// to derive an account with a legacy Ed25519 key scheme
const { mnemonic, address, path } = wallet;
const account = Account.fromDerivationPath({
  path,
  mnemonic,
  scheme: SigningSchemeInput.Ed25519,
});

// to derive an account with a Single Sender Ed25519 key scheme
const { mnemonic, address, path } = wallet;
const account = Account.fromDerivationPath({
  path,
  mnemonic,
  scheme: SigningSchemeInput.Ed25519,
  legacy: false,
});

// to derive an account with a Single Sender Secp256k1 key scheme
const { mnemonic, address, path } = wallet;
const account = Account.fromDerivationPath({
  path,
  mnemonic,
  scheme: SigningSchemeInput.Secp256k1Ecdsa,
});

Derivable Account Abstraction
Derivable Account Abstraction (DAA) is a standard for account abstraction that enables custom authentication schemes by registering a derivable_authentication_function.

DAA differs from vanilla Account Abstraction (AA) in that, for a given derivable_authentication_function, it defines how to deterministically derive the account address from an abstract_public_key, which can be done off-chain.

In contrast, vanilla AA is enabled for a specific pre-existing account by explicitly registering an on-chain authentication_function and submitting a transaction, which involves extra steps and costs gas for each account.

This allows registering secondary authentication schemes with identical user experience to the native ones. More specifically, this provides a flexible and secure way to manage cross-chain signatures. (see x-chain accounts)

Core Concepts
Authentication function
DAA works by defining an custom authentication scheme and registering a valid authentication function to perform on-chain authentication.

Each abstract account should have an associated abstract_public_key and should be able to produce abstract_signatures whose formats depend on the authentication scheme.

Simply put, the derivable_authentication_function needs to check that:

the abstract_signature is valid for the given abstract_public_key
the abstract_signature depends on the transaction’s digest
// The function should return a signer if authentication is successful, otherwise it aborts the execution
public fun authenticate(account: signer, auth_data: AbstractionAuthData): signer;

The DAA framework automatically checks whether the address derived from abstract_public_key matches with the signer’s address.

Authentication data
AbstractionAuthData is an enum that represent the authentication data to be passed to custom authentication functions. It’s used in all flavors of AA, but the DerivableV1 variant defines the following fields:

digest: The SHA3-256 hash of the signing message.
abstract_signature: Abstract signature bytes that need to be verified against abstract_public_key.
abstract_public_key: Abstract public key bytes associated to the abstract account
Here’s what the Move enum looks like:

enum AbstractionAuthData has copy, drop {
  V1 { ... }, // Only applicable to vanilla AA
  DerivableV1 {
      digest: vector<u8>, // SHA3-256 hash of the signing message
      abstract_signature: vector<u8>,
      abstract_public_key: vector<u8>,
  }
}

Why is the digest important?

The digest is checked by the MoveVM to ensure that the signing message of the transaction being submitted is the same as the one presented in the AbstractionAuthData. This is important because it allows the authentication function to verify signatures with respect to the correct transaction.

For example, if you want to permit a public key to sign transactions on behalf of the user, you can permit the public key to sign a transaction with a specific payload. However, if a malicious user sends a signature for the correct public key but a different payload from the digest, the signature will not be valid.

Account address derivation
With DAA, a given derivable_authentication_function defines a space of account addresses that can be deterministically derived from their associated abstract_public_key.

The on-chain function looks like the following:

public fun derive_account_address(derivable_func_info: FunctionInfo, abstract_public_key: &vector<u8>): address {
  let bytes = bcs::to_bytes(&derivable_func_info);
  bytes.append(bcs::to_bytes(abstract_public_key));
  bytes.push_back(DERIVABLE_ABSTRACTION_DERIVED_SCHEME);
  from_bcs::to_address(hash::sha3_256(bytes))
}

where FunctionInfo is a fully qualified identifier for a on-chain function:

struct FunctionInfo has copy, drop, store {
    module_address: address,
    module_name: String,
    function_name: String
}

The address derivation depends on the authentication function’s identifier and on a DAA-specific domain separator. Because of this, each address space is isolated from the others and it’s not possible for the same account to have multiple authentication functions.

Example (Move)

This example demonstrates domain account abstraction using ed25519 hex for signing.

module aptos_experimental::test_derivable_account_abstraction_ed25519_hex {
    use std::error;
    use aptos_std::string_utils;
    use aptos_std::ed25519::{
        Self,
        new_signature_from_bytes,
        new_unvalidated_public_key_from_bytes,
    };
    use aptos_framework::auth_data::AbstractionAuthData;

    const EINVALID_SIGNATURE: u64 = 1;

    /// Authorization function for derivable account abstraction.
    public fun authenticate(account: signer, aa_auth_data: AbstractionAuthData): signer {
    let hex_digest = string_utils::to_string(aa_auth_data.digest());

    let public_key = new_unvalidated_public_key_from_bytes(*aa_auth_data.derivable_abstract_public_key());
    let signature = new_signature_from_bytes(*aa_auth_data.derivable_abstract_signature());
    assert!(
        ed25519::signature_verify_strict(
            &signature,
            &public_key,
            *hex_digest.bytes(),
        ),
        error::permission_denied(EINVALID_SIGNATURE)
    );

    account
    }
}

Example (Typescript)

const derivableAbstractedAccount = new DerivableAbstractedAccount({
  /**
   * The result of the signer function will be available as the `abstract_signature` field in the `AbstractionAuthData` enum variant.
   */
  signer: (digest) => {
    const hexDigest = new TextEncoder().encode(Hex.fromHexInput(digest).toString());
    return solanaAccount.sign(hexDigest).toUint8Array();
  },
  /**
   * The authentication function to be invoked.
   */
  authenticationFunction: `0x7::test_derivable_account_abstraction_ed25519_hex::authenticate`,
  /**
  * The abstract public key (i.e the account identity)
  */
  abstractPublicKey: account.publicKey.toUint8Array(),
});

Minimal Step-by-Step Guide
Generate a ED25519 key pair
const ed25519Account = Account.generate();

Create a DAA
const daa = new DerivableAbstractedAccount({
  signer: (digest) => {
    const hexDigest = new TextEncoder().encode(Hex.fromHexInput(digest).toString());
    return ed25519Account.sign(hexDigest).toUint8Array();
  },
  authenticationFunction: `0x7::test_derivable_account_abstraction_ed25519_hex::authenticate`,
  abstractPublicKey: ed25519Account.publicKey.toUint8Array(),
});

Fund the DAA to create it on chain
await aptos.fundAccount({ accountAddress: daa.accountAddress, amount: 1000000 });

Create a recipient account and transfer APT to it
const recipient = Account.generate();

const pendingTxn = await aptos.transaction.signAndSubmitTransaction({
  signer: daa,
  transaction: await aptos.transferCoinTransaction({
    sender: daa.accountAddress,
    recipient: recipient.accountAddress,
    amount: 100,
  }),
});

const response = await aptos.waitForTransaction({ transactionHash: pendingTxn.hash });

Building Transactions
Transactions allow you to change on-chain data or trigger events. Generally, transactions follow 5 steps from building to executing on chain: building, simulating, signing, submitting, and waiting.

Note

For these examples, aptos is an instance of the Aptos client object.

Build

Building a transaction is how you specify:

The sender account.
This account normally pays the gas fees for this transaction. See Transaction Sponsoring to learn how to have another account pay for fees.
The function being called on-chain.
This is the identifier for the smart contract entry function on-chain that will trigger when you execute this transaction.
The functionArguments.
This is any data the function needs to run.
This can be packaged into a SimpleTransaction using aptos.transaction.build.simple(...) like so:

const transaction = await aptos.transaction.build.simple({
  sender: sender.accountAddress,
  data: {
    // All transactions on Aptos are implemented via smart contracts.
    function: "0x1::aptos_account::transfer",
    functionArguments: [destination.accountAddress, 100],
  },
});

Note

There is a more advanced format to pass in functionArguments called Binary Canonical Serialization (BCS) format which is how the Aptos chain parses function arguments. The SDK converts TypeScript primitives to BCS format behind the scenes via an API call.

Building Options
You can customize the way your transaction executes by passing in options: {...} when building. Some of the most commonly used options are:

maxGasAmount - This caps the amount of gas you are willing to pay for to execute this transaction.
gasUnitPrice - You can specify a higher than minimum price per gas to be executed with higher priority by the Aptos network.
expireTimestamp - This gives a concrete time the transaction must execute by or it will be canceled.
The SDK provides sensible defaults for these values if they are not specified explicitly.

Simulate (Optional)

Every transaction on the Aptos chain has a gas fee associated with how much work the network machines have to do when executing the transaction. In order to estimate the cost associated with that, you can simulate transactions before committing them.

Note

This simulation only requires the publicKey of an account since it will not impact the actual state of the ledger.

You can execute the simulation by using aptos.transaction.simulate.simple(...) like so:

const [userTransactionResponse] = await aptos.transaction.simulate.simple({
  signerPublicKey: signer.publicKey,
  transaction,
});
// If the fee looks ok, continue to signing!

Sign

Once the transaction is built and the fees seem reasonable, you can sign the transaction with aptos.transaction.sign. The signature must come from the sender account.

// 3. Sign
const senderAuthenticator = aptos.transaction.sign({
  signer: sender,
  transaction,
});

Submit

Now that the transaction is signed, you can submit it to the network using aptos.transaction.submit.simple like so:

// 4. Submit
const committedTransaction = await aptos.transaction.submit.simple({
  transaction,
  senderAuthenticator,
});

Wait

Finally, you can wait for the result of the transaction by using aptos.waitForTransaction and specifying the hash of the transaction you just submitted like so:

// 5. Wait
const executedTransaction = await aptos.waitForTransaction({ transactionHash: committedTransaction.hash });

Full TypeScript Example
/**
 * This example shows how to use the Aptos SDK to send a transaction.
 * Don't forget to install @aptos-labs/ts-sdk before running this example!
 */

import {
    Account,
    Aptos,
    AptosConfig,
    Network,
} from "@aptos-labs/ts-sdk";

async function example() {
    console.log("This example will create two accounts (Alice and Bob) and send a transaction transfering APT to Bob's account.");

    // 0. Setup the client and test accounts
    const config = new AptosConfig({ network: Network.DEVNET });
    const aptos = new Aptos(config);

    let alice = Account.generate();
    let bob = Account.generate();

    console.log("=== Addresses ===\n");
    console.log(`Alice's address is: ${alice.accountAddress}`);
    console.log(`Bob's address is: ${bob.accountAddress}`);

    console.log("\n=== Funding accounts ===\n");
    await aptos.fundAccount({
        accountAddress: alice.accountAddress,
        amount: 100_000_000,
    });
    await aptos.fundAccount({
        accountAddress: bob.accountAddress,
        amount: 100,
    });
    console.log("Funded Alice and Bob's accounts!")

    // 1. Build
    console.log("\n=== 1. Building the transaction ===\n");
    const transaction = await aptos.transaction.build.simple({
        sender: alice.accountAddress,
        data: {
        // All transactions on Aptos are implemented via smart contracts.
        function: "0x1::aptos_account::transfer",
        functionArguments: [bob.accountAddress, 100],
        },
    });
    console.log("Built the transaction!")

    // 2. Simulate (Optional)
    console.log("\n === 2. Simulating Response (Optional) === \n")
    const [userTransactionResponse] = await aptos.transaction.simulate.simple({
        signerPublicKey: alice.publicKey,
        transaction,
    });
    console.log(userTransactionResponse)

    // 3. Sign
    console.log("\n=== 3. Signing transaction ===\n");
    const senderAuthenticator = aptos.transaction.sign({
        signer: alice,
        transaction,
    });
    console.log("Signed the transaction!")

    // 4. Submit
    console.log("\n=== 4. Submitting transaction ===\n");
    const submittedTransaction = await aptos.transaction.submit.simple({
        transaction,
        senderAuthenticator,
    });

    console.log(`Submitted transaction hash: ${submittedTransaction.hash}`);

    // 5. Wait for results
    console.log("\n=== 5. Waiting for result of transaction ===\n");
    const executedTransaction = await aptos.waitForTransaction({ transactionHash: submittedTransaction.hash });
    console.log(executedTransaction)
};

example();

Summary
Building and sending transactions on-chain involves the following 5 steps:

Build the transaction.
Simulate the cost. (Optional)
Sign the transaction (if the simulated cost seems ok).
Submit the transaction to the network.
Wait for the chain to validate and update.
Explore Advanced Transaction Features
Transactions have a couple of additional features which let them adapt to your needs which you can learn about here:

Multi-Agent Transactions - Allowing multiple accounts to interact with a single transaction.
Orderless Transactions - Allowing for transactions to be executed out of order for easier management.
Sponsoring Transactions - Have another account pay gas fees for this transaction.
Batch Submit Transactions - How to send multiple transactions quickly from a single account.
Binary Canonical Serialization (BCS) - The format used to serialize data for Aptos transactions.
Composing multiple Move calls with ScriptComposer - (Experimental) Building more complex transaction payload that calls into multiple Move functions dynamically.

Batching Transactions
The TypeScript SDK has a built-in way to send several independent transactions together in a batch. This can be a convenient tool when trying to execute multiple transactions quickly from the same account.

This can be done with aptos.transaction.batch.forSingleAccount as can be seen in the below example.

Full TypeScript Example
/**
 * This example shows how to use the Aptos SDK to send several transactions in a batch.
 */

import {
    Account,
    Aptos,
    AptosConfig,
    Network,
    InputGenerateTransactionPayloadData,
} from "@aptos-labs/ts-sdk";

async function example() {
    console.log("This example will send several transactions in a batch.");

    // Setup the client and test accounts
    const config = new AptosConfig({ network: Network.DEVNET });
    const aptos = new Aptos(config);

    let sender = Account.generate();

    console.log("=== Addresses ===\n");
    console.log(`Sender's address is: ${sender.accountAddress}`);

    console.log("\n=== Funding sender ===\n");
    await aptos.fundAccount({
        accountAddress: sender.accountAddress,
        amount: 100_000_000,
    });
    console.log("Funded the sender account!")

    // Generate several recipients to send APT to
    const recipients = [Account.generate(), Account.generate(), Account.generate()];

    // Create transactions to send APT to each account
    const transactions: InputGenerateTransactionPayloadData[] = [];

    for (let i = 0; i < recipients.length; i += 1) {
        const transaction: InputGenerateTransactionPayloadData = {
            function: "0x1::aptos_account::transfer",
            functionArguments: [recipients[i].accountAddress, 10],
        };
        transactions.push(transaction);
    }

    // Sign and submit all transactions as fast as possible (throws if any error)
    await aptos.transaction.batch.forSingleAccount({ sender: sender, data: transactions });
};

example();

Checking The Status of Batched Transactions
In order to tell when transaction submitted in a batch have executed on chain, you must listen to events while the process runs.

export enum TransactionWorkerEventsEnum {
  // Fired after a transaction gets sent to the chain
  TransactionSent = "transactionSent",
  // Fired if there is an error sending the transaction to the chain
  TransactionSendFailed = "transactionSendFailed",
  // Fired when a single transaction has executed successfully
  TransactionExecuted = "transactionExecuted",
  // Fired if a single transaction fails in execution
  TransactionExecutionFailed = "transactionExecutionFailed",
  // Fired when the worker has finished its job / when the queue has been emptied
  ExecutionFinish = "executionFinish",
}

You can find an example of how to listen to these events here.

BCS Format
Behind the scenes, the Aptos SDK has two formats for transaction parameters:

Simple - This represents transaction parameters using primitive types like strings, integers, etc.
Binary Canonical Serialization (BCS) - This is the format the Aptos chain recognizes, with specific types (ex. Instead of an integer, it uses types like U64 or U128)
Normally, the TypeScript SDK will automatically convert simple types in function parameters into BCS in order to communicate with the network. For some contracts though, you will have to use BCS directly to specify complicated types.

Using BCS directly can have a light performance advantage as the SDK can skip an API call to transform the TypeScript primitive parameter format into BCS format.

You can directly use the BCS format to build transactions by specifying argument types explicitly like so:

const transaction = await aptos.transaction.build.simple({
    sender: alice.accountAddress,
    data: {
      function: "0x1::aptos_account::transfer",
      functionArguments: [AccountAddress.fromString("0x123"), new U64(1_000_000)],
    },
  });

You can learn more about BCS by exploring the BCS GitHub repo.

Multi-Agent Transactions
Multi-agent transactions allow multiple accounts to participate in the logic of a Move contract.

This can be used to require multiple parties agree to a transaction before executing or to use resources from multiple accounts.

Writing Multi-Agent Transactions
Creating and executing a multi-agent transaction follows a similar flow to the simple transaction flow, but with several notable differences.

Note

Instead of .simple, multi-agent transaction functions use .multiAgent.

Build the transaction by including secondarySignerAddresses with a list of each additional agent.

Note

Make sure to replace the function field below with your entry function that requires multiple agents to sign.

const transaction = await aptos.transaction.build.multiAgent({
  sender: alice.accountAddress,
  secondarySignerAddresses: [bob.accountAddress],
  data: {
    // REPLACE WITH YOUR MULTI-AGENT FUNCTION HERE
    function:
      "<REPLACE WITH YOUR MULTI AGENT MOVE ENTRY FUNCTION> (Syntax {address}::{module}::{function})",
    // Pass in arguments for the function you specify above
    functionArguments: [],
  },
});

(Optional) Simulate the transaction.

You can simulate the multi-agent transaction to preview the result before submitting it as follows:

const [userTransactionResponse] = await aptos.transaction.simulate.multiAgent(
  {
    signerPublicKey: alice.publicKey,
    secondarySignersPublicKeys: [bob.publicKey],
    transaction,
  },
);

The signerPublicKey and secondarySignersPublicKeys inputs are optional and can be omitted to skip authentication key checks for the signers during simulation. If you want to skip the authentication key check for only some of the secondary signers, you can provide secondarySignersPublicKeys with the public keys of the specific signers you want to check, using undefined as a placeholder for the others.

For example, if bob and carol are secondary signers and you only want to check carol’s authentication key, you can set secondarySignersPublicKeys: [undefined, carol.publicKey], leaving undefined as a placeholder for bob.

Sign once for each agent.

You will combine these signatures in the next step.

const aliceSenderAuthenticator = aptos.transaction.sign({
  signer: alice,
  transaction,
});
// Bob is a secondary signer for this transaction
const bobSenderAuthenticator = aptos.transaction.sign({
  signer: bob,
  transaction,
});

Submit the transaction by combining all agent signatures via the additionalSignerAuthenticators parameter.

const committedTransaction = await aptos.transaction.submit.multiAgent({
  transaction,
  senderAuthenticator: aliceSenderAuthenticator,
  additionalSignersAuthenticators: [bobSenderAuthenticator],
});

Lastly, wait for the transaction to resolve.

const executedTransaction = await aptos.waitForTransaction({
  transactionHash: committedTransaction.hash,
});

Full TypeScript Multi-Agent Code Snippet
Caution

The below snippet needs light editing to work properly! (See below steps)

Install @aptos-labs/ts-sdk by running pnpm i @aptos-labs/ts-sdk or using whichever package manager is most comfortable for you.
Update the below snippet to build a transaction that requires multi-agent signing.
Replace the function and parameters below this comment: // REPLACE WITH YOUR MULTI-AGENT FUNCTION HERE
This customization is needed as there are no pre-made Aptos contracts which need multi-agent signatures. If you want to deploy your own example multi-agent contract, you can deploy the “transfer two by two” example Move contract.
/**
 * This example shows how to use the Aptos SDK to send a transaction.
 */

import { Account, Aptos, AptosConfig, Network } from "@aptos-labs/ts-sdk";

async function example() {
  console.log(
    "This example will create two accounts (Alice and Bob) and send a transaction transfering APT to Bob's account.",
  );

  // 0. Setup the client and test accounts
  const config = new AptosConfig({ network: Network.DEVNET });
  const aptos = new Aptos(config);

  let alice = Account.generate();
  let bob = Account.generate();
  let carol = Account.generate();

  console.log("=== Addresses ===\n");
  console.log(`Alice's address is: ${alice.accountAddress}`);
  console.log(`Bob's address is: ${bob.accountAddress}`);
  console.log(`Carol's address is: ${carol.accountAddress}`);

  console.log("\n=== Funding accounts ===\n");
  await aptos.fundAccount({
    accountAddress: alice.accountAddress,
    amount: 100_000_000,
  });
  await aptos.fundAccount({
    accountAddress: bob.accountAddress,
    amount: 100_000_000,
  });
  await aptos.fundAccount({
    accountAddress: carol.accountAddress,
    amount: 100_000_000,
  });
  console.log("Done funding Alice, Bob, and Carol's accounts.");

  // 1. Build
  console.log("\n=== 1. Building the transaction ===\n");
  const transaction = await aptos.transaction.build.multiAgent({
    sender: alice.accountAddress,
    secondarySignerAddresses: [bob.accountAddress],
    data: {
      // REPLACE WITH YOUR MULTI-AGENT FUNCTION HERE
      function:
        "<REPLACE WITH YOUR MULTI AGENT MOVE ENTRY FUNCTION> (Syntax {address}::{module}::{function})",
      functionArguments: [],
    },
  });
  console.log("Transaction:", transaction);

  // 2. Simulate (Optional)
  console.log("\n === 2. Simulating Response (Optional) === \n");
  const [userTransactionResponse] = await aptos.transaction.simulate.multiAgent(
    {
      signerPublicKey: alice.publicKey,
      secondarySignersPublicKeys: [bob.publicKey],
      transaction,
    },
  );
  console.log(userTransactionResponse);

  // 3. Sign
  console.log("\n=== 3. Signing transaction ===\n");
  const aliceSenderAuthenticator = aptos.transaction.sign({
    signer: alice,
    transaction,
  });
  const bobSenderAuthenticator = aptos.transaction.sign({
    signer: bob,
    transaction,
  });
  console.log(aliceSenderAuthenticator);
  console.log(bobSenderAuthenticator);

  // 4. Submit
  console.log("\n=== 4. Submitting transaction ===\n");
  const committedTransaction = await aptos.transaction.submit.multiAgent({
    transaction,
    senderAuthenticator: aliceSenderAuthenticator,
    additionalSignersAuthenticators: [bobSenderAuthenticator],
  });
  console.log("Submitted transaction hash:", committedTransaction.hash);

  // 5. Wait for results
  console.log("\n=== 5. Waiting for result of transaction ===\n");
  const executedTransaction = await aptos.waitForTransaction({
    transactionHash: committedTransaction.hash,
  });
  console.log(executedTransaction);
}

example();

Common Errors
NUMBER_OF_SIGNER_ARGUMENTS_MISMATCH - This happens when you are attempting to do multi-agent signing for a function which does not require that number of accounts. For example, if you try using multiple signatures for a 0x1::aptos_account::transfer function - it only expects one address, and so produces an error when more than one is provided.

Orderless Transactions
Orderless transactions allow you to create transactions that do not specify a order of execution between them. This is particularly useful in scenarios where multiple machines need to sign a transaction, but the order in which they sign does not affect the outcome of the transaction or matter to the creator.

Building Orderless Transactions
Creating and executing a multi-agent transaction follows a similar flow to the simple transaction flow, and the multi-agent transaction flow.

Note

Instead of providing a sequenceNumber (or no sequence number at all), a Replay Protection Nonce is used to ensure that the transaction is unique and cannot be replayed (i.e., executed multiple times with the same nonce).

For example, to create a single signer transaction that uses orderless transactions, specify the nonce in the build.simple method like so:

const transaction = await aptos.transaction.build.simple({
  sender: sender.accountAddress,
  data: {
    // All transactions on Aptos are implemented via smart contracts.
    function: "0x1::aptos_account::transfer",
    functionArguments: [destination.accountAddress, 100],
  },
  options: {
    replayProtectionNonce: 12345, // This is the nonce that will be used to ensure the transaction is unique.
  }
});

Similarly, if you are building a multi-agent transaction, you can specify the replayProtectionNonce in the build.multiAgent method:

const transaction = await aptos.transaction.build.multiAgent({
  sender: sender.accountAddress,
  secondarySignerAddresses: [bob.accountAddress], // List of secondary signers
  data: {
    // All transactions on Aptos are implemented via smart contracts.
    function: "0x1::aptos_account::transfer",
    functionArguments: [destination.accountAddress, 100],
  },
  options: {
    replayProtectionNonce: 12345, // This is the nonce that will be used to ensure the transaction is unique.
  }
});

And the same if you are building a sponsored transaction, you can specify the replayProtectionNonce in the build.multiAgent method:

const transaction = await aptos.transaction.build.multiAgent({
  sender: sender.accountAddress,
  withFeePayer: true, // This indicates that the transaction will be sponsored.
  data: {
    // All transactions on Aptos are implemented via smart contracts.
    function: "0x1::aptos_account::transfer",
    functionArguments: [destination.accountAddress, 100],
  },
  options: {
    replayProtectionNonce: 12345, // This is the nonce that will be used to ensure the transaction is unique.
  }
});

Note

For orderless transactions, the replayProtectionNonce must be unique for each transaction. Additionally, the expiration time of the transaction is maximum 60 seconds from the time it is submitted. If the transaction is not executed within that time, it will be considered expired and will not be executed.

After that, simply follow the same steps as you would for a simple transaction:

Simulate the transaction (optional).
Sign the transaction.
Submit the transaction to the network.
Wait for the transaction to be executed.

Invoke chains of Move calls with Dynamic Script Composer
Tip

We are pleased to announce that we now have an independent package for the Script Composer functionality, which can be found in the following repository:

https://github.com/aptos-labs/script-composer-sdk

Of course! You can use it as an npm package! Please install this package:

https://www.npmjs.com/package/@aptos-labs/script-composer-sdk

Caution

If you are still using the Script Composer in the 1.39.0 version of the ts-sdk, you can switch to the independent package version as soon as possible: https://www.npmjs.com/package/@aptos-labs/ts-sdk/v/1.39.0

Overview
In the basic API, you can only specify one entry function call for a single transaction. Advanced builders might want to invoke multiple public Move functions in one transaction. This is now enabled by the new scriptComposer API provided in the transaction builder.

Basic Usage
Here’s an example of how to invoke the API:

Please note that the current example is only for reference on how to use Script Composer to combine transactions, receive return values from public functions, and pass them to the next function

const tx = await BuildScriptComposerTransaction({
    // You need to fill in the sender's address here
    sender: singleSignerED25519SenderAccount.accountAddress,
    builder: async (composer) => {
        // Start by withdrawing some Coin
        const coin = await composer.addBatchedCalls({
            function: "0x1::coin::withdraw",
            functionArguments: [CallArgument.newSigner(0), 1],
            typeArguments: ["0x1::aptos_coin::AptosCoin"],
        });

        // Pass the coin value to 0x1::coin::coin_to_fungible_asset to convert the token
        // into a fungible asset
        const fungibleAsset = await composer.addBatchedCalls({
            function: "0x1::coin::coin_to_fungible_asset",
            // coin[0] represents the first return value from the first call you added
            functionArguments: [coin[0]],
            typeArguments: ["0x1::aptos_coin::AptosCoin"],
        });

        // Deposit the fungibleAsset converted from the second call
        await composer.addBatchedCalls({
            function: "0x1::primary_fungible_store::deposit",
            // You need to fill in the sender's address here
            functionArguments: [singleSignerED25519SenderAccount.accountAddress, fungibleAsset[0]],
            typeArguments: [],
        });
        return composer
    },
    // You need to pass Aptos Config here because the combined transaction needs to read on-chain state
    aptosConfig: new AptosConfig({
        network: Network.TESTNET,
    }),
});

Transaction Processing
After combining the transaction, we can use interfaces like sign transaction / simulate transaction / submit transaction from @aptos-labs/ts-sdk:

We’ll use the simulate transaction interface to show how to use it:

...

    const aptos = new Aptos(new AptosConfig({
        network: Network.TESTNET,
    }));

    const simulate_result = await aptos.transaction.simulate.simple({
        transaction: tx,
    })

    console.log('simulate_result: ', simulate_result)
...

Examples
If you need some practical examples, we have also prepared usage examples for three common environments:

In the examples, you will see a combined transaction and the return value of the simulated transaction (the simulated transaction uses the 0x1 address as the sender. Although it can be simulated successfully by default, if you want to actually use this feature to initiate a simulated transaction, please replace it with your account address and set up the corresponding network)

nodejs: https://github.com/aptos-labs/script-composer-sdk/tree/main/examples/nodejs
nextjs: https://github.com/aptos-labs/script-composer-sdk/tree/main/examples/nextjs-project
react: https://github.com/aptos-labs/script-composer-sdk/tree/main/examples/react-project
Technical Principles
Under the hood, the SDK will invoke a WASM binary to compile the series of Move calls into a CompiledScript. This will guarantee that the type and ability safety of Move is still being honored during the construction process. For the SDK users, this means:

Ability safety: a. If the returned value does not have the Drop ability, the returned value needs to be consumed by subsequent calls. b. If the returned value does not have the Copy ability, the returned value can only be passed to subsequent calls once.
The caller will need to make sure they pass the right values as arguments to subsequent calls. In the previous example, the 0x1::coin::coin_to_fungible_asset function will expect an argument of Coin<AptosCoin>.

Simulating Transactions
Simulating transactions allows you to preview the cost and effect of submitting a transaction without paying fees. You can use this to estimate fees, test a transaction, or to check what the output might be.

To simulate a transaction, you must pass in a transaction and which account would be the signer:

import {
    Account,
    Aptos,
    AptosConfig,
    Network,
} from "@aptos-labs/ts-sdk";

async function example() {
    let sender = Account.generate();
    let receiver = Account.generate();

    // 0. Setup the client and test accounts
    const config = new AptosConfig({ network: Network.DEVNET });
    const aptos = new Aptos(config);

    await aptos.fundAccount({
        accountAddress: sender.accountAddress,
        amount: 100_000_000,
    });

    // 1. Build the transaction to preview the impact of it
    const transaction = await aptos.transaction.build.simple({
        sender: sender.accountAddress,
        data: {
        // All transactions on Aptos are implemented via smart contracts.
        function: "0x1::aptos_account::transfer",
        functionArguments: [receiver.accountAddress, 100],
        },
    });

    // 2. Simulate to see what would happen if we execute this transaction
    const [userTransactionResponse] = await aptos.transaction.simulate.simple({
        signerPublicKey: sender.publicKey,
        transaction,
    });
    console.log(userTransactionResponse)

    // If the fee looks ok, continue to signing!
    // ...
}

example();

This will produce the same output as if the transaction was submitted.

The signerPublicKey parameter in aptos.transaction.simulate.simple is used to verify the signer’s authentication key during transaction simulation. This parameter is optional, and simulation will bypass checking the authentication key if omitted. For example below:

// 2. Simulate to see what would happen if we execute this transaction, skipping the authentication key check
const [userTransactionResponse] = await aptos.transaction.simulate.simple({
    transaction,
});

Example Output
Look here to see the full example of how to build, simulate, and submit a transaction.

Simulating more advanced Transactions
You can also learn how to simulate more advanced transactions by looking at the following guides:

Sponsored Transactions
Multi-Agent Transactions
Multisig V2 Transactions: See the next section for details.
Simulating On-Chain Multisig (v2) Transactions
For multisig transactions, there are two types of simulation:

Simulation of the target payload before it’s submitted on-chain, ignoring the voting status.
Simulation of the approved on-chain multisig transaction before execution to verify output and gas estimation.
To perform the first type, you can simulate the target payload as a sponsored transaction with the multisig account as the sender, and set the fee payer to 0x0 to bypass gas fee payment during simulation. For example:

// Generate a raw transaction with the multisig address as the sender,
// the provided entry function payload, and 0x0 as the fee payer address.
const transactionToSimulate = await aptos.transaction.build.simple({
  sender: multisigAddress,
  data: {
    function: "0x1::aptos_account::transfer",
    functionArguments: [recipient.accountAddress, 1_000_000],
  },
  withFeePayer: true,
});

// Simulate the transaction, skipping the public/auth key check for both the sender and the fee payer.
const [simulateMultisigTx] = await aptos.transaction.simulate.simple({
  transaction: transactionToSimulate,
});

This setup allows you to preview the target payload’s result before submitting it on-chain. Here, signerPublicKey is omitted to skip the authentication key check for the sender, as the multisig account does not have a public key. Additionally, feePayerAddress defaults to 0x0, and feePayerPublicKey is omitted to bypass the gas fee payment during simulation. When this payload is later executed after submission and approval, the owner executing the transaction will cover the gas fee.

For the second type of simulation, where the on-chain multisig payload transaction is simulated for final validation and gas estimation, use the following approach:

const transactionPayload: TransactionPayloadMultiSig = await generateTransactionPayload({
  multisigAddress,
  function: "0x1::aptos_account::transfer",
  functionArguments: [recipient.accountAddress, 1_000_000],
  aptosConfig: config,
});

const rawTransaction = await generateRawTransaction({
  aptosConfig: config,
  sender: owner.accountAddress,
  payload: transactionPayload,
});

const [simulateMultisigTx] = await aptos.transaction.simulate.simple({
  signerPublicKey: owner.publicKey,
  transaction: new SimpleTransaction(rawTransaction),
});

Note that signerPublicKey is optional and can be omitted if you wish to skip the authentication key check for the sender during simulation.

For the complete source code, see the Multisig V2 Example.

Sponsoring Transactions
Normally, the account that is executing a transaction pays for the gas fees. You can allow another account to cover those charges by sponsoring a transaction.

This can be used to help manage fees from a central account when working with complicated smart contracts.

How To Sponsor a Transaction
Build the transaction with the parameter withFeePayer: true.

const transaction = await aptos.transaction.build.simple({
    sender: sender.accountAddress,
    withFeePayer: true,
    data: {
        // All transactions on Aptos are implemented via smart contracts.
        function: "0x1::aptos_account::transfer",
        functionArguments: [destination.accountAddress, 100],
    },
});

Sign the transaction with BOTH the sender and the feePayer.

Sign with the sender account using .sign.
Sign with the sponsor account using .signAsFeePayer.
Caution

The sponsor uses a different function (.signAsFeePayer) than the sender to sign!

const senderAuthenticator = aptos.transaction.sign({
    signer: sender,
    transaction,
});
const feePayerAuthenticator = aptos.transaction.signAsFeePayer({
    signer: feePayer,
    transaction
})

(Optional) Simulate the sponsoring transaction

You can simulate the sponsoring transaction to preview the result before submitting it as follows:

const [userTransactionResponse] = await aptos.transaction.simulate.simple({
    signerPublicKey: sender.publicKey,
    transaction,
});

By default, the transaction’s feePayerAddress is set to 0x0, which directs the transaction simulation to skip the gas fee payment. This allows you to simulate the transaction without specifying a fee payer. Note that signerPublicKey is optional and can be omitted if you want to skip the authentication key check for the sender.

You can also simulate the transaction with a specific fee payer by setting the feePayerAddress in the transaction object as follows:

transaction.feePayerAddress = feePayer.accountAddress;
const [userTransactionResponse] = await aptos.transaction.simulate.simple({
    signerPublicKey: sender.publicKey,
    feePayerPublicKey: feePayer.publicKey,
    transaction,
});

This setup will verify that feePayer has sufficient balance to cover the gas fee for the transaction. Similarly, feePayerPublicKey is optional and can be omitted if you wish to bypass the authentication key check for the fee payer.

Submit the transaction by combining both signatures.

// 4. Submit
const committedTransaction = await aptos.transaction.submit.simple({
    transaction,
    senderAuthenticator: senderAuthenticator,
    feePayerAuthenticator: feePayerAuthenticator,
});

Wait for the transaction to execute.

// 5. Wait for results
const executedTransaction = await aptos.waitForTransaction({ transactionHash: committedTransaction.hash });

TypeScript Sponsor Transaction Code Sample
/**
 * This example shows how to use the Aptos SDK to send a transaction with a sponsor.
 */

import {
    Account,
    Aptos,
    AptosConfig,
    Network,
} from "@aptos-labs/ts-sdk";

async function example() {
    console.log("This example will send a sponsored transaction from Alice to Carol.");

    // 0. Setup the client and test accounts
    const config = new AptosConfig({ network: Network.DEVNET });
    const aptos = new Aptos(config);

    let alice = Account.generate();
    let bob = Account.generate();
    let carol = Account.generate();

    console.log("=== Addresses ===\n");
    console.log(`Alice's address is: ${alice.accountAddress}`);
    console.log(`Bob's address is: ${bob.accountAddress}`);
    console.log(`Carol's address is: ${carol.accountAddress}`);

    console.log("\n=== Funding accounts ===\n");
    await aptos.fundAccount({
        accountAddress: alice.accountAddress,
        amount: 500_000_000,
    });
    await aptos.fundAccount({
        accountAddress: bob.accountAddress,
        amount: 500_000_000,
    });
    await aptos.fundAccount({
        accountAddress: carol.accountAddress,
        amount: 100,
    });
    console.log("Funded the accounts!")

    // 1. Build
    console.log("\n=== 1. Building the transaction ===\n");
    const transaction = await aptos.transaction.build.simple({
        sender: alice.accountAddress,
        withFeePayer: true,
        data: {
            // All transactions on Aptos are implemented via smart contracts.
            function: "0x1::aptos_account::transfer",
            functionArguments: [carol.accountAddress, 100],
        },
    });
    console.log("Built the transaction!")

    // 2. Sign
    console.log("\n=== 2. Signing transaction ===\n");
    const aliceSenderAuthenticator = aptos.transaction.sign({
        signer: alice,
        transaction,
    });
    const bobSenderAuthenticator = aptos.transaction.signAsFeePayer({
        signer: bob,
        transaction
    })
    console.log("Signed the transaction!")

    // 3. Simulate (Optional)
    console.log("\n === 3. Simulating Response (Optional) === \n")
    const [userTransactionResponse] = await aptos.transaction.simulate.simple({
        signerPublicKey: alice.publicKey,
        feePayerPublicKey: bob.publicKey,
        transaction,
    });
    console.log(userTransactionResponse)

    // 4. Submit
    console.log("\n=== 4. Submitting transaction ===\n");
    const committedTransaction = await aptos.transaction.submit.simple({
        transaction,
        senderAuthenticator: aliceSenderAuthenticator,
        feePayerAuthenticator: bobSenderAuthenticator,
    });
    console.log("Submitted transaction hash:", committedTransaction.hash);

    // 5. Wait for results
    console.log("\n=== 5. Waiting for result of transaction ===\n");
    const executedTransaction = await aptos.waitForTransaction({ transactionHash: committedTransaction.hash });
    console.log(executedTransaction)
};

example();

Common Errors
INSUFFICIENT_BALANCE_FOR_TRANSACTION_FEE :

This may be caused by accidentally using .sign instead of .signAsFeePayer when signing the transaction before submitting on-chain.
Sponsoring a transaction requires that the sponsoring account have enough funds to cover the max possible gas fee. This is often orders of magnitude larger than the expected or actual gas fees required for a transaction to execute. In this case, increase the funds in the account above the max_gas_amount multiplied by the gas_unit_price in the simulated transaction. These must be multiplied because gas is unitless, and so must be multiplied by the conversion rate from gas to octas. You can learn more about gas here.

Python SDK
Aptos provides a lightly maintained official Python SDK. It is available on PyPi with the source code in the aptos-python-sdk GitHub repository. Much of the functionality of the Python SDK mirrors the Typescript SDK. The primary purpose of the Python SDK is to help Python developers to quickly become familiar with Aptos and as an accompaniment to Aptos tutorials.

Installing Python SDK
The Python SDK can either be installed via pip, from source, or embedded:

Install with pip
To install via pip:

Terminal window
pip3 install aptos-sdk

The aptos-sdk will be installed in the local site packages directory. For example, on macOS, you will find the aptos-sdk in the ~/Library/Python/3.8/lib/python/site-packages/aptos_sdk directory.

Install from the source code
To install from source:

Terminal window
git clone https://github.com/aptos-labs/aptos-python-sdk
pip3 install . --user

Install by embedding
To embed the Python SDK into your existing Python project:

Terminal window
cd /path/to/python/project
cp -r /path/to/aptos-python-sdk aptos-sdk

Using the Python SDK
See the Developer Tutorials for code examples showing how to use the Python SDK.

Unity SDK
Caution

This SDK is currently in beta. Please report any issues you encounter by creating an issue in the aptos-labs/unity-sdk repository.

Integrate Aptos Web3 capabilities within your Unity applications. The goal of this SDK is to provide a set of tools for developers to build Web3 games using the Unity game engine.

Supported Features

Support for the Aptos .NET SDK

Binary Canonical Serialization (BCS) encoding and decoding
Ed25519, SingleKey, MultiKey, and Keyless signer support
Utilities for transaction building, signing, and submission
Abstractions over the Aptos Fullnode and Indexer APIs
Aptos Names (ANS) support for resolution and lookup
Compatibility

.NET Version	Supported
.NET Standard 2.1	✅
Installation
Install via Unity Package Manager (UPM)
Open the Unity Package Manager (Window > Package Manager).
Click on the + button and select Add package from git URL....
Enter the URL of the Aptos Unity SDK path in this repository:
Terminal window
https://github.com/aptos-labs/unity-sdk.git?path=/Packages/com.aptoslabs.aptos-unity-sdk

Install via unitypackage
Go to the aptos-labs/unity-sdk Releases and download the latest release.
Drag and drop the .unitypackage file into your Unity project.
Usage
Set up your Aptos client by adding the Aptos namespace and instantiating an AptosUnityClient. You can use a predefined configuration from Networks or configuring your own.

using UnityEngine;
using Aptos;

class Example : MonoBehaviour
{
    public void Start()
    {
        PrintLedgerInfo();
    }

    async void PrintLedgerInfo() {
        var client = new AptosUnityClient(Networks.Mainnet);
        var ledgerInfo = await client.Block.GetLedgerInfo();
        Debug.Log(ledgerInfo.BlockHeight);
    }

}

To interact with the blockchain, you will need to create a signer and build a transaction.

using UnityEngine;
using Aptos;

class Example : MonoBehaviour
{
    public async void Start()
    {
        var client = new AptosUnityClient(Networks.Mainnet);

        // 1. Create a signer
        var signer = Account.Generate();

        // 2. Build the transaction
        var transaction = await client.Transaction.Build(
            sender: account,
            data: new GenerateEntryFunctionPayloadData(
                function: "0x1::aptos_account::transfer_coins",
                typeArguments: ["0x1::aptos_coin::AptosCoin"],
                functionArguments: [account.Address, "100000"]
            )
        );

        // 3. Sign and submit the transaction
        var pendingTransaction = client.Transaction.SignAndSubmitTransaction(account, transaction);

        // 4. (Optional) Wait for the transaction to be committed
        var committedTransaction = await client.Transaction.WaitForTransaction(pendingTransaction);
    }
}

create-aptos-dapp
create-aptos-dapp builds a template project for dapp developers to easily create a front-end and a smart contract on the Aptos network.

Why use create-aptos-dapp?
Templated Setup: create-aptos-dapp generates predefined end-to-end dapp templates and configuration files for you. It saves manual setup of the project structure, which can be time-consuming and error-prone.
Contract Directory: create-aptos-dapp generates a contract directory that includes the basic structure for Move smart contract modules.
Best Practices: create-aptos-dapp incorporates best practices and structure recommendations to develop for the Aptos network.
Built-in Move Commands: create-aptos-dapp includes built-in commands for common tasks, such as initializing the Move compiler, compiling, and publishing smart contracts on-chain.
Prerequisites
node and npm (npm ≥ 5.2.0)
Python 3.6+
Using create-aptos-dapp
Navigate to the directory you want to work in.

Terminal window
cd your/workspace

Install create-aptos-dapp.

npx
pnpx
yarn
pnpm
Terminal window
npx create-aptos-dapp@latest

Follow the CLI prompts.

After installing, you will need to answer several questions about your project including:

The project’s name
Which template to use (see below)
Whether to use Mainnet or Devnet for testing
cad

Templates
create-aptos-dapp provides you with premade end-to-end dapp templates, i.e. a ready dapp with configurations and a beautiful UI to get you started with creating a dapp on Aptos.

The goals of the templates are to:

Familiarize users with different Aptos Standards by having an end-to-end dapp template examples.
Educate users on how to build a dapp on Aptos from the front-end layer to the smart contract layer and how everything in-between.
Provide users with pre-made templates to quickly deploy simple dapps
Current Templates
All current templates are available on Aptos Learn. Read more about specific templates below:

Boilerplate Template
NFT minting dapp Template
Token minting dapp Template
Token staking dapp Template
Custom indexer template
Tools create-aptos-dapp utilizes
React framework
Vite development tool
shadcn/ui + tailwind for styling
Aptos TS SDK
Aptos Wallet Adapter
Node based Move commands